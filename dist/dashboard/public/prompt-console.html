<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPECMEM // PROMPT CONSOLE</title>

    <!-- xterm.js for terminal -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Orbitron:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --csgo-yellow: #FFD700;
            --csgo-yellow-dark: #B8860B;
            --csgo-yellow-glow: rgba(255, 215, 0, 0.5);
            --csgo-black: #000000;
            --csgo-dark: #0a0a0a;
            --csgo-darker: #050505;
            --csgo-gray: #1a1a1a;
            --csgo-gray-light: #2a2a2a;
            --csgo-text: #e0e0e0;
            --csgo-text-dim: #888888;
            --csgo-success: #4CAF50;
            --csgo-error: #f44336;
            --csgo-warning: #ff9800;
            --csgo-border: #333333;
            --csgo-code-bg: #0d1117;
        }

        body {
            font-family: 'Rajdhani', 'Segoe UI', sans-serif;
            background: var(--csgo-black);
            color: var(--csgo-text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background:
                linear-gradient(90deg, rgba(255,215,0,0.03) 1px, transparent 1px),
                linear-gradient(rgba(255,215,0,0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        .console-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        .header {
            grid-column: 1 / -1;
            height: 60px;
            background: linear-gradient(180deg, var(--csgo-dark) 0%, var(--csgo-black) 100%);
            border-bottom: 2px solid var(--csgo-yellow);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.2);
        }

        .logo {
            font-family: 'Orbitron', monospace;
            font-size: 20px;
            font-weight: 700;
            color: var(--csgo-yellow);
            text-shadow: 0 0 10px var(--csgo-yellow-glow);
            letter-spacing: 2px;
        }

        .logo span { color: var(--csgo-text); font-weight: 400; }

        .header-actions { display: flex; gap: 10px; }

        .sidebar {
            background: var(--csgo-dark);
            border-right: 1px solid var(--csgo-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-section { border-bottom: 1px solid var(--csgo-border); }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: var(--csgo-gray);
            cursor: pointer;
        }

        .sidebar-header h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--csgo-yellow);
        }

        .sidebar-content {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--csgo-yellow) var(--csgo-dark);
        }

        .history-item {
            padding: 10px 15px;
            border-bottom: 1px solid var(--csgo-border);
            cursor: pointer;
            transition: background 0.2s;
        }

        .history-item:hover { background: rgba(255, 215, 0, 0.1); }

        .history-item.active {
            background: rgba(255, 215, 0, 0.15);
            border-left: 3px solid var(--csgo-yellow);
        }

        .history-prompt {
            font-size: 13px;
            color: var(--csgo-text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }

        .history-meta {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--csgo-text-dim);
        }

        .context-item {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            border-bottom: 1px solid var(--csgo-border);
            font-size: 12px;
        }

        .context-item input[type="checkbox"] {
            margin-right: 10px;
            accent-color: var(--csgo-yellow);
        }

        .context-item label { flex: 1; cursor: pointer; }

        .context-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 10px 15px;
        }

        .context-chip {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            border-radius: 15px;
            font-size: 11px;
            color: var(--csgo-text);
        }

        .context-chip .remove {
            cursor: pointer;
            color: var(--csgo-error);
            font-weight: bold;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .response-viewer {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: var(--csgo-darker);
            scrollbar-width: thin;
            scrollbar-color: var(--csgo-yellow) var(--csgo-dark);
        }

        .response-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--csgo-text-dim);
            text-align: center;
        }

        .response-empty h2 {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            color: var(--csgo-yellow);
            margin-bottom: 10px;
        }

        .response-content {
            font-family: 'Rajdhani', sans-serif;
            font-size: 15px;
            line-height: 1.6;
            color: var(--csgo-text);
        }

        .response-content h1, .response-content h2, .response-content h3 {
            color: var(--csgo-yellow);
            margin: 20px 0 10px;
        }

        .response-content pre {
            background: var(--csgo-code-bg);
            border: 1px solid var(--csgo-border);
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            margin: 10px 0;
            position: relative;
        }

        .response-content code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .response-content p code {
            background: var(--csgo-code-bg);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .response-meta {
            display: flex;
            gap: 20px;
            padding: 10px 20px;
            background: var(--csgo-gray);
            border-top: 1px solid var(--csgo-border);
            font-size: 12px;
            color: var(--csgo-text-dim);
        }

        .response-meta span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .response-meta .value {
            color: var(--csgo-yellow);
            font-family: 'Orbitron', monospace;
        }

        .prompt-input-container {
            background: var(--csgo-dark);
            border-top: 2px solid var(--csgo-yellow);
            padding: 15px 20px;
        }

        .config-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .config-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .config-item label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--csgo-text-dim);
            white-space: nowrap;
        }

        .config-item input[type="range"] {
            width: 80px;
            accent-color: var(--csgo-yellow);
        }

        .config-item select {
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            color: var(--csgo-text);
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 3px;
        }

        .config-item .value {
            font-family: 'Orbitron', monospace;
            font-size: 11px;
            color: var(--csgo-yellow);
            min-width: 35px;
        }

        .system-prompt-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 11px;
            color: var(--csgo-text-dim);
            text-transform: uppercase;
        }

        .system-prompt-container {
            margin-bottom: 10px;
            display: none;
        }

        .system-prompt-container.visible { display: block; }

        .system-prompt-textarea {
            width: 100%;
            height: 60px;
            resize: vertical;
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            border-radius: 5px;
            padding: 10px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 13px;
            color: var(--csgo-text);
            outline: none;
        }

        .system-prompt-textarea:focus {
            border-color: var(--csgo-yellow);
        }

        .prompt-row { display: flex; gap: 10px; }

        .prompt-textarea {
            flex: 1;
            min-height: 80px;
            max-height: 200px;
            resize: vertical;
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            border-radius: 5px;
            padding: 12px 15px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 15px;
            color: var(--csgo-text);
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        .prompt-textarea:focus {
            border-color: var(--csgo-yellow);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .prompt-textarea::placeholder { color: var(--csgo-text-dim); }

        .send-btn {
            padding: 0 30px;
            background: linear-gradient(135deg, var(--csgo-yellow) 0%, var(--csgo-yellow-dark) 100%);
            border: none;
            border-radius: 5px;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 600;
            color: var(--csgo-black);
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }

        .send-btn:active { transform: translateY(0); }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .send-btn.loading {
            position: relative;
            color: transparent;
        }

        .send-btn.loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--csgo-black);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .btn {
            padding: 8px 15px;
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            border-radius: 5px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 13px;
            font-weight: 600;
            color: var(--csgo-text);
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: var(--csgo-gray-light);
            border-color: var(--csgo-yellow);
            color: var(--csgo-yellow);
        }

        .btn-small { padding: 4px 10px; font-size: 11px; }

        .btn-primary {
            background: linear-gradient(135deg, var(--csgo-yellow) 0%, var(--csgo-yellow-dark) 100%);
            border-color: var(--csgo-yellow);
            color: var(--csgo-black);
        }

        .btn-primary:hover {
            color: var(--csgo-black);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--csgo-dark);
            border: 1px solid var(--csgo-yellow);
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            background: var(--csgo-gray);
            border-bottom: 1px solid var(--csgo-border);
        }

        .modal-header h3 {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            color: var(--csgo-yellow);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--csgo-text-dim);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .modal-close:hover { color: var(--csgo-error); }

        .modal-body {
            padding: 20px;
            max-height: calc(80vh - 120px);
            overflow-y: auto;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 15px 20px;
            border-top: 1px solid var(--csgo-border);
        }

        .selector-search {
            width: 100%;
            margin-bottom: 15px;
            padding: 10px 15px;
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            border-radius: 5px;
            font-size: 14px;
            color: var(--csgo-text);
            outline: none;
        }

        .selector-search:focus { border-color: var(--csgo-yellow); }

        .selector-list { max-height: 300px; overflow-y: auto; }

        .selector-item {
            display: flex;
            align-items: flex-start;
            padding: 10px;
            border-bottom: 1px solid var(--csgo-border);
            cursor: pointer;
        }

        .selector-item:hover { background: rgba(255, 215, 0, 0.1); }

        .selector-item input {
            margin-right: 10px;
            margin-top: 4px;
            accent-color: var(--csgo-yellow);
        }

        .selector-item-content { flex: 1; }

        .selector-item-title {
            font-size: 14px;
            color: var(--csgo-text);
            margin-bottom: 3px;
        }

        .selector-item-meta {
            font-size: 11px;
            color: var(--csgo-text-dim);
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background: var(--csgo-dark);
            border: 1px solid var(--csgo-yellow);
            border-radius: 5px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            animation: slideIn 0.3s ease-out;
        }

        .notification.error { border-color: var(--csgo-error); }
        .notification.success { border-color: var(--csgo-success); }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--csgo-dark); }
        ::-webkit-scrollbar-thumb { background: var(--csgo-gray); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--csgo-yellow); }

        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .loading-dots { display: flex; gap: 8px; }

        .loading-dots span {
            width: 12px;
            height: 12px;
            background: var(--csgo-yellow);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
        .loading-dots span:nth-child(3) { animation-delay: 0s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* ============================================
         * SPLIT-SCREEN LAYOUT - FR FR NO CAP
         * Team Member 1's masterpiece for live thinking view
         * ============================================ */

        .splitscreen-container {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Left pane - where the convo at */
        .whereTheConvoAt {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--csgo-darker);
        }

        /* The divider you can drag around like a boss */
        .draggableDividerYeet {
            width: 8px;
            background: linear-gradient(180deg, var(--csgo-gray) 0%, var(--csgo-dark) 100%);
            cursor: col-resize;
            position: relative;
            z-index: 100;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .draggableDividerYeet:hover,
        .draggableDividerYeet.dragging {
            background: var(--csgo-yellow);
            box-shadow: 0 0 10px var(--csgo-yellow-glow);
        }

        .draggableDividerYeet::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: var(--csgo-border);
            border-radius: 2px;
        }

        .draggableDividerYeet:hover::before,
        .draggableDividerYeet.dragging::before {
            background: var(--csgo-black);
        }

        /* Right pane - whereClaudeBeThinking */
        .whereClaudeBeThinking {
            width: 400px;
            min-width: 250px;
            max-width: 60%;
            display: flex;
            flex-direction: column;
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.02) 0%, var(--csgo-darker) 100%);
            border-left: 1px solid var(--csgo-border);
            overflow: hidden;
        }

        .whereClaudeBeThinking.collapsed {
            width: 0;
            min-width: 0;
            border-left: none;
        }

        /* Thinking pane header - that fire header */
        .thinkingPaneHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: var(--csgo-gray);
            border-bottom: 1px solid var(--csgo-border);
        }

        .thinkingPaneHeader h3 {
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            color: var(--csgo-yellow);
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .thinkingPaneHeader h3::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--csgo-yellow);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .thinkingPaneHeader .toggle-btn {
            background: none;
            border: 1px solid var(--csgo-border);
            color: var(--csgo-text-dim);
            padding: 4px 8px;
            font-size: 10px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .thinkingPaneHeader .toggle-btn:hover {
            border-color: var(--csgo-yellow);
            color: var(--csgo-yellow);
        }

        /* Live thinking content area */
        .liveThinkingContent {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.6;
            color: var(--csgo-text);
        }

        /* Individual thinking block container */
        .thinkingBlockYeet {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(255, 215, 0, 0.03);
            border: 1px solid rgba(255, 215, 0, 0.1);
            border-radius: 5px;
            border-left: 3px solid var(--csgo-yellow);
            animation: slideInRight 0.3s ease-out;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .thinkingBlockYeet .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed rgba(255, 215, 0, 0.2);
        }

        .thinkingBlockYeet .block-num {
            font-size: 10px;
            color: var(--csgo-yellow);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .thinkingBlockYeet .block-time {
            font-size: 9px;
            color: var(--csgo-text-dim);
        }

        .thinkingBlockYeet .block-content {
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Streaming status indicator */
        .streamingStatusBruh {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(255, 215, 0, 0.05);
            border-bottom: 1px solid var(--csgo-border);
            font-size: 11px;
            color: var(--csgo-text-dim);
        }

        .streamingStatusBruh.active {
            color: var(--csgo-yellow);
        }

        .streamingStatusBruh .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--csgo-text-dim);
        }

        .streamingStatusBruh.active .status-dot {
            background: var(--csgo-yellow);
            animation: pulse 1s infinite;
        }

        /* Empty state for thinking pane */
        .thinkingEmptyState {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--csgo-text-dim);
            text-align: center;
            padding: 20px;
        }

        .thinkingEmptyState h4 {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            color: var(--csgo-yellow);
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .thinkingEmptyState p {
            font-size: 12px;
            opacity: 0.7;
        }

        /* Toggle button to show/hide thinking pane */
        .toggleThinkingBtn {
            position: absolute;
            right: 10px;
            top: 10px;
            z-index: 50;
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            color: var(--csgo-text-dim);
            padding: 6px 12px;
            font-size: 10px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toggleThinkingBtn:hover {
            border-color: var(--csgo-yellow);
            color: var(--csgo-yellow);
        }

        .streaming-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 5px 12px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid var(--csgo-yellow);
            border-radius: 15px;
            font-size: 11px;
            color: var(--csgo-yellow);
            margin-bottom: 15px;
        }

        .streaming-dot {
            width: 8px;
            height: 8px;
            background: var(--csgo-yellow);
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            background: var(--csgo-gray);
            border: 1px solid var(--csgo-border);
            border-radius: 3px;
            color: var(--csgo-text-dim);
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .response-content pre:hover .copy-btn { opacity: 1; }
        .copy-btn:hover { background: var(--csgo-yellow); color: var(--csgo-black); }

        .deploy-section {
            padding: 10px 15px;
            border-bottom: 1px solid var(--csgo-border);
        }

        .deploy-btn {
            width: 100%;
            padding: 10px;
            background: var(--csgo-gray);
            border: 1px dashed var(--csgo-border);
            border-radius: 5px;
            color: var(--csgo-text-dim);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .deploy-btn:hover {
            border-color: var(--csgo-yellow);
            color: var(--csgo-yellow);
            background: rgba(255, 215, 0, 0.05);
        }

        @media (max-width: 768px) {
            .console-container { grid-template-columns: 1fr; }
            .sidebar { display: none; }
            .header { padding: 0 10px; }
            .prompt-input-container { padding: 10px; }
            .config-bar { flex-direction: column; gap: 10px; }
        }

        /* claude code history entries no cap */
        .cc-entry {
            padding: 8px 12px;
            border-bottom: 1px solid var(--csgo-border);
            cursor: pointer;
            transition: background 0.2s;
        }
        .cc-entry:hover { background: rgba(255, 215, 0, 0.1); }
        .cc-header {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 4px;
        }
        .cc-role {
            font-size: 10px;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 3px;
            background: var(--csgo-gray-light);
        }
        .cc-user .cc-role { background: #1a472a; color: #4CAF50; }
        .cc-assistant .cc-role { background: #1a1a47; color: #64B5F6; }
        .cc-system .cc-role { background: #472a1a; color: #ff9800; }
        .cc-type {
            font-size: 9px;
            color: var(--csgo-yellow);
            padding: 1px 4px;
            border: 1px solid var(--csgo-yellow);
            border-radius: 2px;
        }
        .cc-time {
            font-size: 9px;
            color: var(--csgo-text-dim);
            margin-left: auto;
        }
        .cc-content {
            font-size: 11px;
            color: var(--csgo-text);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
    </style>
    <script src="/shared-logger.js"></script>
</head>
<body>
    <div class="console-container">
        <header class="header">
            <div class="logo">SPECMEM <span>// PROMPT CONSOLE</span></div>
            <div class="header-actions">
                <button class="btn" onclick="clearHistory()">Clear History</button>
                <button class="btn" onclick="window.location.href='/'">Dashboard</button>
            </div>
        </header>

        <aside class="sidebar">
            <section class="sidebar-section">
                <div class="sidebar-header" onclick="toggleSection(this)">
                    <h3>Model Config</h3>
                    <span>-</span>
                </div>
                <div class="sidebar-content" id="modelConfigSection">
                    <div class="context-item">
                        <label style="width: 100%;">
                            Model
                            <!-- Updated model list with correct Claude model IDs and REAL context limits -->
                            <select id="modelSelect" style="width: 100%; margin-top: 5px; background: var(--csgo-gray); border: 1px solid var(--csgo-border); color: var(--csgo-text); padding: 8px;" onchange="updateModelContextLimit()">
                                <option value="claude-sonnet-4-5-20250929" data-context="200000" selected>Sonnet 4.5 (200k context)</option>
                                <option value="claude-opus-4-5-20251101" data-context="200000">Opus 4.5 (200k context)</option>
                                <option value="claude-3-5-haiku-20241022" data-context="200000">Haiku 3.5 (200k context)</option>
                            </select>
                        </label>
                    </div>
                    <div class="context-item" style="margin-top: 5px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <span style="font-size: 11px; color: var(--csgo-text-dim);">Context Limit:</span>
                            <span id="contextLimitDisplay" style="font-family: 'Orbitron', monospace; font-size: 12px; color: var(--csgo-yellow);">200K tokens</span>
                        </div>
                    </div>
                    <div class="context-item">
                        <label style="width: 100%;">
                            Temperature: <span id="temperatureValue" style="color: var(--csgo-yellow);">0.7</span>
                            <input type="range" id="temperature" min="0" max="100" value="70" style="width: 100%; margin-top: 5px;" oninput="updateTemperature(this)">
                        </label>
                    </div>
                    <div class="context-item" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="enableThinking" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: var(--csgo-yellow); font-weight: 500;">Enable Extended Thinking</span>
                        </label>
                        <div style="color: var(--csgo-text-dim); font-size: 12px; margin-top: 5px; margin-left: 26px;">
                            Allows Claude to think deeply before responding (uses more tokens)
                        </div>
                    </div>
                </div>
            </section>

            <section class="sidebar-section">
                <div class="sidebar-header" onclick="toggleSection(this)">
                    <h3>Context</h3>
                    <span>-</span>
                </div>
                <div class="sidebar-content" id="contextSection">
                    <div class="context-item">
                        <input type="checkbox" id="includeCodebase" onchange="updateContext()">
                        <label for="includeCodebase">Include Codebase Context</label>
                    </div>
                    <div style="padding: 10px 15px;">
                        <button class="btn btn-small" onclick="openMemorySelector()">+ Add Memories</button>
                        <button class="btn btn-small" onclick="openFileSelector()" style="margin-left: 5px;">+ Add Files</button>
                    </div>
                    <div class="context-chips" id="contextChips"></div>
                </div>
            </section>

            <section class="sidebar-section">
                <div class="sidebar-header" onclick="toggleSection(this)">
                    <h3>Live Session Status</h3>
                    <span>-</span>
                </div>
                <div class="sidebar-content" id="liveStatusSection">
                    <div class="context-item" style="display: flex; flex-direction: column; gap: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span id="liveStreamDot" style="width: 10px; height: 10px; border-radius: 50%; background: var(--csgo-text-dim);"></span>
                            <span id="liveStreamStatus" style="font-size: 11px; color: var(--csgo-text-dim);">Connecting...</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--csgo-text-dim);">
                            <span>Entries: <span id="liveEntryCount" style="color: var(--csgo-yellow);">0</span></span>
                            <span>Thinking: <span id="liveThinkingCount" style="color: var(--csgo-yellow);">0</span></span>
                        </div>
                        <button class="btn btn-small" onclick="toggleLiveStream()" style="width: 100%; margin-top: 5px;">
                            <span id="liveToggleText">Connect Live</span>
                        </button>
                    </div>
                </div>
            </section>

            <section class="sidebar-section" style="flex: 1; overflow: hidden;">
                <div class="sidebar-header" onclick="toggleSection(this)">
                    <h3>History</h3>
                    <span>-</span>
                </div>
                <div class="sidebar-content" id="historySection" style="max-height: none; flex: 1;"></div>
            </section>
        </aside>

        <main class="main-content">
            <!-- SPLIT-SCREEN CONTAINER - LIVE CLAUDE CODE SESSION VIEWER -->
            <div class="splitscreen-container">
                <!-- LEFT PANE: LIVE TERMINAL -->
                <div class="whereTheConvoAt" id="whereTheConvoAt">
                    <div class="live-pane-header" style="display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; background: var(--csgo-gray); border-bottom: 1px solid var(--csgo-border);">
                        <h3 style="font-family: 'Orbitron', monospace; font-size: 12px; color: var(--csgo-yellow); text-transform: uppercase; letter-spacing: 2px; display: flex; align-items: center; gap: 8px;">
                            <span id="terminalStatusDot" style="width: 8px; height: 8px; background: var(--csgo-text-dim); border-radius: 50%;"></span>
                            Live Terminal
                        </h3>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <select id="instanceSelector" style="background: var(--csgo-gray); border: 1px solid var(--csgo-border); color: var(--csgo-text); padding: 4px 8px; font-size: 10px; border-radius: 3px; cursor: pointer; font-family: 'Rajdhani', sans-serif;">
                                <option value="">Loading instances...</option>
                            </select>
                            <button class="toggle-btn" id="newInstanceBtn" style="background: none; border: 1px solid var(--csgo-yellow); color: var(--csgo-yellow); padding: 4px 8px; font-size: 10px; border-radius: 3px; cursor: pointer; position: static;">+ New</button>
                            <button class="toggle-btn" id="startStreamBtn" style="background: none; border: 1px solid var(--csgo-border); color: var(--csgo-text-dim); padding: 4px 8px; font-size: 10px; border-radius: 3px; cursor: pointer; position: static;">Start Stream</button>
                            <button class="toggle-btn" id="stopStreamBtn" style="background: none; border: 1px solid var(--csgo-border); color: var(--csgo-text-dim); padding: 4px 8px; font-size: 10px; border-radius: 3px; cursor: pointer; position: static;" disabled>Stop Stream</button>
                            <button id="toggleThinkingBtn" onclick="yeetToggleThinkingPane()" style="background: none; border: 1px solid var(--csgo-border); color: var(--csgo-text-dim); padding: 4px 8px; font-size: 10px; border-radius: 3px; cursor: pointer; position: static; font-family: 'Rajdhani', sans-serif; text-transform: uppercase; letter-spacing: 1px;">
                                Show Thinking
                            </button>
                        </div>
                    </div>
                    <div id="terminal" style="flex: 1; padding: 10px; background: #000;"></div>
                </div>

                <!-- DRAGGABLE DIVIDER -->
                <div class="draggableDividerYeet" id="draggableDividerYeet"></div>

                <!-- RIGHT PANE: LIVE THINKING VIEW (UNLIMITED) -->
                <div class="whereClaudeBeThinking" id="whereClaudeBeThinking">
                    <div class="thinkingPaneHeader">
                        <h3 style="display: flex; align-items: center; gap: 8px;">
                            <span id="liveThinkingDot" style="width: 8px; height: 8px; background: var(--csgo-text-dim); border-radius: 50%;"></span>
                            Live Thinking (Unlimited)
                        </h3>
                        <button class="toggle-btn" onclick="yeetClearThinking()">Clear</button>
                    </div>
                    <div class="streamingStatusBruh" id="streamingStatusBruh">
                        <span class="status-dot"></span>
                        <span id="streamingStatusText">Connecting to live stream...</span>
                    </div>
                    <div class="liveThinkingContent" id="liveThinkingContent">
                        <div class="thinkingEmptyState">
                            <h4>Waiting for Thinking Blocks</h4>
                            <p>Extended thinking content from Claude will appear here in real-time as it's generated. No limits on how much can be displayed.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="response-meta" id="responseMeta" style="display: none;">
                <span>Model: <span class="value" id="metaModel">-</span></span>
                <span>Tokens: <span class="value" id="metaTokens">-</span></span>
                <span>Duration: <span class="value" id="metaDuration">-</span></span>
                <span>Thinking Blocks: <span class="value" id="metaThinkingBlocks">-</span></span>
                <div style="flex: 1;"></div>
                <button class="btn btn-small" onclick="copyResponse()">Copy</button>
                <button class="btn btn-small" onclick="exportResponse()">Export</button>
            </div>

            <div class="prompt-input-container">
                <div class="system-prompt-container" id="systemPromptContainer">
                    <textarea class="system-prompt-textarea" id="systemPrompt" placeholder="System prompt (optional)..."></textarea>
                </div>
                <div class="config-bar">
                    <!-- TEAM MEMBER 3 FIX: Removed token limits - UNLIMITED by default! -->
                    <div class="config-item">
                        <label>Max Tokens</label>
                        <input type="range" id="maxTokens" min="1000" max="200000" value="128000" step="1000" oninput="updateSliderValue(this)">
                        <span class="value" id="maxTokensValue">128K (Unlimited)</span>
                    </div>
                    <div class="config-item">
                        <label>Intelligence</label>
                        <input type="range" id="intelligencePriority" min="0" max="100" value="80" oninput="updateSliderValue(this)">
                        <span class="value" id="intelligencePriorityValue">0.8</span>
                    </div>
                    <div class="config-item">
                        <label>Speed</label>
                        <input type="range" id="speedPriority" min="0" max="100" value="50" oninput="updateSliderValue(this)">
                        <span class="value" id="speedPriorityValue">0.5</span>
                    </div>
                    <div class="system-prompt-toggle" onclick="toggleSystemPrompt()">
                        <span id="systemPromptToggleIcon">+</span> System Prompt
                    </div>
                </div>
                <div class="prompt-row">
                    <textarea
                        class="prompt-textarea"
                        id="promptInput"
                        placeholder="Enter your prompt here... (Ctrl+Enter to send)"
                        rows="3"
                    ></textarea>
                    <button class="send-btn" id="sendBtn" onclick="sendPrompt()">SEND</button>
                </div>
            </div>
        </main>
    </div>

    <div class="modal-overlay" id="memoryModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Select Memories</h3>
                <button class="modal-close" onclick="closeModal('memoryModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="text" class="selector-search" placeholder="Search memories..." id="memorySearch" oninput="searchMemories(this.value)">
                <div class="selector-list" id="memoryList">
                    <div class="loading-indicator">
                        <div class="loading-dots"><span></span><span></span><span></span></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('memoryModal')">Cancel</button>
                <button class="btn btn-primary" onclick="confirmMemorySelection()">Add Selected</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="fileModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Select Files</h3>
                <button class="modal-close" onclick="closeModal('fileModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="text" class="selector-search" placeholder="Search files..." id="fileSearch" oninput="searchFiles(this.value)">
                <div class="selector-list" id="fileList">
                    <div class="loading-indicator">
                        <div class="loading-dots"><span></span><span></span><span></span></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('fileModal')">Cancel</button>
                <button class="btn btn-primary" onclick="confirmFileSelection()">Add Selected</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="deployModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Deploy as TeamMember</h3>
                <button class="modal-close" onclick="closeModal('deployModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 12px; color: var(--csgo-text-dim); margin-bottom: 5px;">TeamMember Name</label>
                    <input type="text" id="deployTeamMemberName" class="selector-search" placeholder="My TeamMember" style="margin-bottom: 0;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 12px; color: var(--csgo-text-dim); margin-bottom: 5px;">TeamMember Type</label>
                    <select id="deployTeamMemberType" style="width: 100%; background: var(--csgo-gray); border: 1px solid var(--csgo-border); color: var(--csgo-text); padding: 10px; border-radius: 5px;">
                        <option value="worker">Worker</option>
                        <option value="overseer">Overseer</option>
                        <option value="qa">QA</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 12px; color: var(--csgo-text-dim); margin-bottom: 5px;">Task Description</label>
                    <textarea id="deployTaskDescription" class="selector-search" style="min-height: 80px; resize: vertical; margin-bottom: 0;" placeholder="Describe the task for this team member..."></textarea>
                </div>
                <div>
                    <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--csgo-text-dim); cursor: pointer;">
                        <input type="checkbox" id="deployUseCurrentPrompt" checked style="accent-color: var(--csgo-yellow);">
                        Use current prompt as initial task
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('deployModal')">Cancel</button>
                <button class="btn btn-primary" onclick="deployTeamMember()">Deploy TeamMember</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // STATE - where all the juicy data lives fr fr
        // ============================================
        const state = {
            selectedMemories: [],
            selectedFiles: [],
            includeCodebase: false,
            currentResponse: null,
            history: [],
            isLoading: false,
            isStreaming: false,
            streamingContent: '',
            websocket: null,
            // Split-screen thinking state
            thinkingPaneVisible: true,
            thinkingBlocks: [],
            currentStreamingThought: '',
            thinkingBlockCount: 0,
            sseConnection: null,
            isDraggingDivider: false,
            dividerStartX: 0,
            thinkingPaneStartWidth: 0,
            // LIVE SESSION STREAMING STATE - Team Member 2's LIVE viewer
            liveSessionSSE: null,
            liveSessionConnected: false,
            liveConversationEntries: [],
            liveEntryCount: 0,
            liveThinkingCount: 0,
            maxLiveEntries: 50 // Keep last 50 messages in conversation view
        };

        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();
            connectWebSocket();
            setupDraggableDividerYeet();

            // TEAM MEMBER 2: Start the LIVE session stream immediately!
            initializeLiveSessionStream();

            // Load initial recent entries
            loadRecentEntries();

            document.getElementById('promptInput').addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'Enter') {
                    sendPrompt();
                }
            });

            const textarea = document.getElementById('promptInput');
            textarea.addEventListener('input', () => {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
            });

            // Update toggle button text based on initial state
            updateToggleButtonText();
        });

        // ============================================
        // LIVE SESSION STREAMING - Team Member 2's MASTERPIECE
        // Real-time Claude Code session viewer!
        // ============================================

        function initializeLiveSessionStream() {
            console.log('Initializing LIVE session stream...');
            updateLiveStreamStatus('connecting', 'Connecting...');

            try {
                state.liveSessionSSE = new EventSource('/api/live/stream');

                state.liveSessionSSE.addEventListener('connected', (e) => {
                    console.log('LIVE stream connected!', e.data);
                    state.liveSessionConnected = true;
                    updateLiveStreamStatus('connected', 'LIVE - Watching');
                    document.getElementById('liveToggleText').textContent = 'Disconnect';
                });

                state.liveSessionSSE.addEventListener('userMessage', (e) => {
                    const entry = JSON.parse(e.data);
                    addLiveConversationEntry(entry);
                });

                state.liveSessionSSE.addEventListener('assistantMessage', (e) => {
                    const entry = JSON.parse(e.data);
                    addLiveConversationEntry(entry);

                    // If there's thinking, also add to thinking pane
                    if (entry.thinking && entry.thinking.length > 0) {
                        for (const thought of entry.thinking) {
                            addThinkingBlock(thought, entry.timestamp);
                        }
                    }
                });

                state.liveSessionSSE.addEventListener('thinking', (e) => {
                    const data = JSON.parse(e.data);
                    addThinkingBlock(data.content, data.timestamp);
                });

                state.liveSessionSSE.addEventListener('toolUse', (e) => {
                    const entry = JSON.parse(e.data);
                    addLiveConversationEntry(entry);
                });

                state.liveSessionSSE.addEventListener('toolResult', (e) => {
                    const entry = JSON.parse(e.data);
                    addLiveConversationEntry(entry);
                });

                state.liveSessionSSE.addEventListener('entry', (e) => {
                    const entry = JSON.parse(e.data);
                    addLiveConversationEntry(entry);
                });

                state.liveSessionSSE.addEventListener('heartbeat', (e) => {
                    // Keep alive - just update timestamp
                    console.debug('Heartbeat received');
                });

                state.liveSessionSSE.onerror = (e) => {
                    console.warn('LIVE stream error:', e);
                    state.liveSessionConnected = false;
                    updateLiveStreamStatus('error', 'Disconnected - Retrying...');

                    // EventSource auto-reconnects, so just wait
                    setTimeout(() => {
                        if (state.liveSessionSSE?.readyState === EventSource.OPEN) {
                            updateLiveStreamStatus('connected', 'LIVE - Watching');
                        }
                    }, 3000);
                };

            } catch (error) {
                console.error('Failed to initialize LIVE stream:', error);
                updateLiveStreamStatus('error', 'Connection Failed');
            }
        }

        function toggleLiveStream() {
            if (state.liveSessionConnected && state.liveSessionSSE) {
                // Disconnect
                state.liveSessionSSE.close();
                state.liveSessionSSE = null;
                state.liveSessionConnected = false;
                updateLiveStreamStatus('disconnected', 'Disconnected');
                document.getElementById('liveToggleText').textContent = 'Connect Live';
            } else {
                // Connect
                initializeLiveSessionStream();
            }
        }

        function updateLiveStreamStatus(statusType, text) {
            const dot = document.getElementById('liveStreamDot');
            const status = document.getElementById('liveStreamStatus');
            const convoDot = document.getElementById('liveConvoDot');
            const thinkingDot = document.getElementById('liveThinkingDot');

            let color = 'var(--csgo-text-dim)';
            if (statusType === 'connected') {
                color = '#4CAF50'; // Green
            } else if (statusType === 'connecting') {
                color = 'var(--csgo-yellow)';
            } else if (statusType === 'error') {
                color = 'var(--csgo-error)';
            }

            if (dot) dot.style.background = color;
            if (convoDot) convoDot.style.background = color;
            if (thinkingDot) thinkingDot.style.background = color;
            if (status) status.textContent = text;

            // Also update the thinking pane status
            updateStreamStatus(statusType === 'connected', text);
        }

        function addLiveConversationEntry(entry) {
            state.liveEntryCount++;
            document.getElementById('liveEntryCount').textContent = state.liveEntryCount;

            // Add to state
            state.liveConversationEntries.push(entry);

            // Trim to max entries
            while (state.liveConversationEntries.length > state.maxLiveEntries) {
                state.liveConversationEntries.shift();
            }

            // Render
            renderLiveConversation();
        }

        function renderLiveConversation() {
            const container = document.getElementById('liveConversationContainer');
            const emptyState = document.getElementById('liveConvoEmpty');

            if (state.liveConversationEntries.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'flex';
                return;
            }

            container.style.display = 'block';
            emptyState.style.display = 'none';

            // TERMINAL-STYLE OUTPUT - Simple text flow like actual Claude Code terminal
            container.innerHTML = state.liveConversationEntries.map(entry => {
                const isUser = entry.type === 'user' || entry.role === 'user';
                const isAssistant = entry.type === 'assistant' || entry.role === 'assistant';

                let content = entry.content || '';

                // User messages - show in green
                if (isUser) {
                    return `<div style="color: #4CAF50; margin-bottom: 8px; font-family: 'JetBrains Mono', monospace; font-size: 13px; line-height: 1.5;">${escapeHtml(content)}</div>`;
                }

                // Assistant messages - show in cyan/blue
                if (isAssistant) {
                    return `<div style="color: #64B5F6; margin-bottom: 8px; font-family: 'JetBrains Mono', monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${escapeHtml(content)}</div>`;
                }

                // Tool use/results - show in yellow
                if (entry.type === 'tool_use' || entry.type === 'tool_result') {
                    const toolLabel = entry.toolName ? `[${entry.toolName}]` : '[Tool]';
                    return `<div style="color: var(--csgo-yellow); margin-bottom: 8px; font-family: 'JetBrains Mono', monospace; font-size: 12px; opacity: 0.7;">${toolLabel} ${escapeHtml(content.substring(0, 200))}</div>`;
                }

                // System messages - show dimmed
                return `<div style="color: var(--csgo-text-dim); margin-bottom: 8px; font-family: 'JetBrains Mono', monospace; font-size: 12px; opacity: 0.6;">${escapeHtml(content)}</div>`;
            }).join('');

            // Auto-scroll to bottom
            const viewer = document.getElementById('responseViewer');
            viewer.scrollTop = viewer.scrollHeight;
        }

        function clearLiveConversation() {
            state.liveConversationEntries = [];
            state.liveEntryCount = 0;
            document.getElementById('liveEntryCount').textContent = '0';
            renderLiveConversation();
        }

        function addThinkingBlock(content, timestamp) {
            state.liveThinkingCount++;
            state.thinkingBlockCount++;
            document.getElementById('liveThinkingCount').textContent = state.liveThinkingCount;

            const thinkingContent = document.getElementById('liveThinkingContent');

            // Clear empty state if present
            const emptyState = thinkingContent.querySelector('.thinkingEmptyState');
            if (emptyState) emptyState.remove();

            const blockId = `thinking-live-${state.thinkingBlockCount}`;
            const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();

            const blockHtml = `
                <div class="thinkingBlockYeet" id="${blockId}">
                    <div class="block-header">
                        <span class="block-num">Thinking Block ${state.thinkingBlockCount}</span>
                        <span class="block-time">${time}</span>
                    </div>
                    <div class="block-content">${escapeHtml(content)}</div>
                </div>
            `;

            thinkingContent.insertAdjacentHTML('beforeend', blockHtml);
            thinkingContent.scrollTop = thinkingContent.scrollHeight;
        }

        async function loadRecentEntries() {
            try {
                const response = await fetch('/api/live/recent?limit=50');
                const data = await response.json();

                if (data.success && data.entries && data.entries.length > 0) {
                    console.log(`Loaded ${data.entries.length} recent entries`);

                    for (const entry of data.entries) {
                        state.liveConversationEntries.push(entry);
                        state.liveEntryCount++;

                        // Extract thinking blocks
                        if (entry.thinking && entry.thinking.length > 0) {
                            for (const thought of entry.thinking) {
                                addThinkingBlock(thought, entry.timestamp);
                            }
                        }
                    }

                    document.getElementById('liveEntryCount').textContent = state.liveEntryCount;
                    renderLiveConversation();
                }
            } catch (error) {
                console.error('Failed to load recent entries:', error);
            }
        }

        function updateModelContextLimit() {
            const select = document.getElementById('modelSelect');
            const option = select.options[select.selectedIndex];
            const contextLimit = option.getAttribute('data-context') || '200000';
            const display = document.getElementById('contextLimitDisplay');
            if (display) {
                display.textContent = (parseInt(contextLimit) / 1000) + 'K tokens';
            }
        }

        // ============================================
        // SPLIT-SCREEN DIVIDER DRAGGING - draggableDividerYeet
        // Team Member 1's sick drag functionality
        // ============================================
        function setupDraggableDividerYeet() {
            const divider = document.getElementById('draggableDividerYeet');
            const thinkingPane = document.getElementById('whereClaudeBeThinking');

            if (!divider || !thinkingPane) return;

            divider.addEventListener('mousedown', (e) => {
                e.preventDefault();
                state.isDraggingDivider = true;
                state.dividerStartX = e.clientX;
                state.thinkingPaneStartWidth = thinkingPane.offsetWidth;
                divider.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', yeetTheDividerAround);
            document.addEventListener('mouseup', letGoOfTheDivider);
        }

        // UNPROFESSIONAL NAME: handle divider dragging
        function yeetTheDividerAround(e) {
            if (!state.isDraggingDivider) return;

            const thinkingPane = document.getElementById('whereClaudeBeThinking');
            const deltaX = state.dividerStartX - e.clientX;
            let newWidth = state.thinkingPaneStartWidth + deltaX;

            // Clamp to min/max
            newWidth = Math.max(250, Math.min(newWidth, window.innerWidth * 0.6));
            thinkingPane.style.width = newWidth + 'px';
        }

        // UNPROFESSIONAL NAME: stop dragging divider
        function letGoOfTheDivider() {
            if (!state.isDraggingDivider) return;

            state.isDraggingDivider = false;
            const divider = document.getElementById('draggableDividerYeet');
            if (divider) divider.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }

        // UNPROFESSIONAL NAME: toggle thinking pane visibility
        function yeetToggleThinkingPane() {
            const thinkingPane = document.getElementById('whereClaudeBeThinking');
            const divider = document.getElementById('draggableDividerYeet');

            state.thinkingPaneVisible = !state.thinkingPaneVisible;

            if (state.thinkingPaneVisible) {
                thinkingPane.classList.remove('collapsed');
                thinkingPane.style.width = '400px';
                divider.style.display = 'block';
            } else {
                thinkingPane.classList.add('collapsed');
                divider.style.display = 'none';
            }

            updateToggleButtonText();
        }

        function updateToggleButtonText() {
            const btn = document.getElementById('toggleThinkingBtn');
            if (btn) {
                btn.textContent = state.thinkingPaneVisible ? 'Hide Thinking' : 'Show Thinking';
            }
        }

        // Clear all thinking blocks
        function yeetClearThinking() {
            state.thinkingBlocks = [];
            state.thinkingBlockCount = 0;
            state.liveThinkingCount = 0;
            state.currentStreamingThought = '';

            document.getElementById('liveThinkingCount').textContent = '0';

            const content = document.getElementById('liveThinkingContent');
            if (content) {
                content.innerHTML = `
                    <div class="thinkingEmptyState">
                        <h4>Thinking Cleared</h4>
                        <p>Waiting for new thinking blocks from Claude...</p>
                    </div>
                `;
            }
        }

        // ============================================
        // SSE STREAMING - catchThemLiveVibes
        // Team Member 1's live thinking stream handler
        // ============================================
        function catchThemLiveVibes() {
            // Connect to SSE endpoint for live thinking stream
            // Team Member 2 should provide the endpoint URL - using /api/stream/thinking for now
            const sseUrl = '/api/stream/thinking';

            try {
                state.sseConnection = new EventSource(sseUrl);

                state.sseConnection.onopen = () => {
                    console.log('SSE thinking stream connected fr fr');
                    updateStreamStatus(true, 'Connected to thinking stream');
                };

                state.sseConnection.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        yeetTheThinkingData(data);
                    } catch (e) {
                        // Plain text thinking chunk
                        yeetTheThinkingData({ type: 'chunk', content: event.data });
                    }
                };

                state.sseConnection.addEventListener('thinking_start', (e) => {
                    console.log('Thinking block started');
                    state.currentStreamingThought = '';
                    state.thinkingBlockCount++;
                    addNewThinkingBlock();
                });

                state.sseConnection.addEventListener('thinking_chunk', (e) => {
                    const data = JSON.parse(e.data);
                    appendToCurrentThinking(data.content);
                });

                state.sseConnection.addEventListener('thinking_end', (e) => {
                    console.log('Thinking block complete');
                    finalizeCurrentThinking();
                });

                state.sseConnection.onerror = (e) => {
                    console.warn('SSE error, will retry...', e);
                    updateStreamStatus(false, 'Connection lost, retrying...');
                    // EventSource auto-reconnects, but let's update status
                    setTimeout(() => {
                        if (state.sseConnection?.readyState === EventSource.OPEN) {
                            updateStreamStatus(true, 'Reconnected');
                        }
                    }, 3000);
                };

            } catch (e) {
                console.error('Failed to setup SSE:', e);
                updateStreamStatus(false, 'SSE not available - using WebSocket fallback');
            }
        }

        // UNPROFESSIONAL NAME: handle incoming thinking data
        function yeetTheThinkingData(data) {
            switch (data.type) {
                case 'thinking_start':
                    state.currentStreamingThought = '';
                    state.thinkingBlockCount++;
                    addNewThinkingBlock();
                    break;
                case 'thinking_chunk':
                case 'chunk':
                    appendToCurrentThinking(data.content || data.text || '');
                    break;
                case 'thinking_end':
                    finalizeCurrentThinking();
                    break;
                case 'response_start':
                    updateStreamStatus(true, 'Response streaming...');
                    break;
                case 'response_end':
                    updateStreamStatus(false, 'Complete');
                    break;
                default:
                    // Handle unknown types gracefully
                    if (data.content) {
                        appendToCurrentThinking(data.content);
                    }
            }
        }

        function updateStreamStatus(active, text) {
            const statusEl = document.getElementById('streamingStatusBruh');
            const statusText = document.getElementById('streamingStatusText');

            if (statusEl && statusText) {
                statusEl.classList.toggle('active', active);
                statusText.textContent = text;
            }
        }

        function addNewThinkingBlock() {
            const content = document.getElementById('liveThinkingContent');
            if (!content) return;

            // Clear empty state if present
            const emptyState = content.querySelector('.thinkingEmptyState');
            if (emptyState) emptyState.remove();

            const blockId = `thinking-block-${state.thinkingBlockCount}`;
            const blockHtml = `
                <div class="thinkingBlockYeet" id="${blockId}">
                    <div class="block-header">
                        <span class="block-num">Thinking Block ${state.thinkingBlockCount}</span>
                        <span class="block-time">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="block-content" id="${blockId}-content"></div>
                </div>
            `;
            content.insertAdjacentHTML('beforeend', blockHtml);

            // Scroll to bottom
            content.scrollTop = content.scrollHeight;
        }

        function appendToCurrentThinking(text) {
            if (!text) return;

            state.currentStreamingThought += text;

            const blockContent = document.getElementById(`thinking-block-${state.thinkingBlockCount}-content`);
            if (blockContent) {
                blockContent.textContent = state.currentStreamingThought;

                // Auto-scroll
                const content = document.getElementById('liveThinkingContent');
                if (content) content.scrollTop = content.scrollHeight;
            }
        }

        function finalizeCurrentThinking() {
            // Save to state
            state.thinkingBlocks.push({
                num: state.thinkingBlockCount,
                content: state.currentStreamingThought,
                timestamp: new Date().toISOString()
            });
            state.currentStreamingThought = '';

            // Update meta display
            const metaBlocks = document.getElementById('metaThinkingBlocks');
            if (metaBlocks) {
                metaBlocks.textContent = state.thinkingBlocks.length;
            }
        }

        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws`;

            state.websocket = new WebSocket(wsUrl);

            state.websocket.onopen = () => {
                console.log('WebSocket connected');
            };

            state.websocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch (e) {
                    console.error('WebSocket message parse error:', e);
                }
            };

            state.websocket.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connectWebSocket, 3000);
            };

            state.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // UNPROFESSIONAL NAME: yeetTheWebSocketData - handle all WS messages fr fr
        function handleWebSocketMessage(data) {
            // Handle thinking stream via WebSocket (fallback if SSE not available)
            if (data.type === 'thinking_stream' || data.type === 'thinking') {
                yeetTheThinkingData(data);
                return;
            }

            if (data.type === 'prompt_stream') {
                if (data.status === 'streaming') {
                    if (!state.isStreaming) {
                        state.isStreaming = true;
                        state.streamingContent = '';
                        updateStreamStatus(true, 'Response streaming...');
                    }
                    state.streamingContent += data.chunk || '';
                    displayStreamingResponse(state.streamingContent);

                    // Also check for inline thinking blocks in the stream
                    if (data.thinking) {
                        yeetTheThinkingData({ type: 'chunk', content: data.thinking });
                    }
                } else if (data.status === 'complete') {
                    state.isStreaming = false;
                    updateStreamStatus(false, 'Complete');
                    if (data.response) {
                        state.currentResponse = data;
                        displayResponse(data);

                        // Extract and display any thinking from final response
                        if (data.thinkingBlocks && data.thinkingBlocks.length > 0) {
                            data.thinkingBlocks.forEach((block, i) => {
                                state.thinkingBlockCount++;
                                addNewThinkingBlock();
                                appendToCurrentThinking(block);
                                finalizeCurrentThinking();
                            });
                        }
                    }
                }
            }
        }

        function displayStreamingResponse(content) {
            const viewer = document.getElementById('responseViewer');
            const htmlContent = renderMarkdown(content);

            viewer.innerHTML = `
                <div class="streaming-indicator">
                    <span class="streaming-dot"></span>
                    Streaming response...
                </div>
                <div class="response-content">${htmlContent}</div>
            `;

            viewer.scrollTop = viewer.scrollHeight;
        }

        async function sendPrompt() {
            const promptInput = document.getElementById('promptInput');
            const prompt = promptInput.value.trim();

            if (!prompt || state.isLoading) return;

            state.isLoading = true;
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.classList.add('loading');
            sendBtn.disabled = true;

            const viewer = document.getElementById('responseViewer');
            viewer.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-dots"><span></span><span></span><span></span></div>
                </div>
            `;

            const systemPrompt = document.getElementById('systemPrompt').value.trim();
            const modelSelect = document.getElementById('modelSelect').value;
            const temperature = parseInt(document.getElementById('temperature').value) / 100;

            try {
                const response = await fetch('/api/prompt/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        context: {
                            memories: state.selectedMemories.map(m => m.id),
                            files: state.selectedFiles.map(f => f.path),
                            codebase: state.includeCodebase
                        },
                        config: {
                            maxTokens: parseInt(document.getElementById('maxTokens').value),
                            intelligencePriority: parseInt(document.getElementById('intelligencePriority').value) / 100,
                            speedPriority: parseInt(document.getElementById('speedPriority').value) / 100,
                            model: modelSelect,
                            temperature: temperature,
                            systemPrompt: systemPrompt || undefined,
                            enableThinking: document.getElementById('enableThinking').checked
                        }
                    })
                });

                const data = await response.json();

                if (data.success) {
                    state.currentResponse = data;
                    displayResponse(data);
                    promptInput.value = '';
                    promptInput.style.height = 'auto';
                    loadHistory();
                } else {
                    showNotification(data.error || 'Failed to send prompt', 'error');
                    viewer.innerHTML = `
                        <div class="response-empty" style="color: var(--csgo-error);">
                            <h2>Error</h2>
                            <p>${data.error || 'Failed to send prompt'}</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error sending prompt:', error);
                showNotification('Network error - please try again', 'error');
                viewer.innerHTML = `
                    <div class="response-empty" style="color: var(--csgo-error);">
                        <h2>Network Error</h2>
                        <p>Could not connect to server</p>
                    </div>
                `;
            } finally {
                state.isLoading = false;
                sendBtn.classList.remove('loading');
                sendBtn.disabled = false;
            }
        }

        function displayResponse(data) {
            const viewer = document.getElementById('responseViewer');
            const meta = document.getElementById('responseMeta');

            const htmlContent = renderWithThinking(data.response);

            viewer.innerHTML = htmlContent;
            meta.style.display = 'flex';

            document.getElementById('metaModel').textContent = data.model || 'claude-3-5-sonnet';
            document.getElementById('metaTokens').textContent = data.tokensUsed || '-';
            document.getElementById('metaDuration').textContent = data.duration ? `${data.duration}ms` : '-';

            viewer.scrollTop = 0;
            addCopyButtonsToCodeBlocks();
        }

        function addCopyButtonsToCodeBlocks() {
            document.querySelectorAll('.response-content pre').forEach(pre => {
                if (!pre.querySelector('.copy-btn')) {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-btn';
                    copyBtn.textContent = 'Copy';
                    copyBtn.onclick = () => {
                        const code = pre.querySelector('code');
                        if (code) {
                            navigator.clipboard.writeText(code.textContent);
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => copyBtn.textContent = 'Copy', 2000);
                        }
                    };
                    pre.appendChild(copyBtn);
                }
            });
        }

        function renderMarkdown(text) {
            if (!text) return '';

            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => {
                return `<pre><code class="language-${lang}">${code.trim()}</code></pre>`;
            });

            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

            html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

            html = html.replace(/^\- (.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');

            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';

            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>(<h[1-3]>)/g, '$1');
            html = html.replace(/(<\/h[1-3]>)<\/p>/g, '$1');
            html = html.replace(/<p>(<pre>)/g, '$1');
            html = html.replace(/(<\/pre>)<\/p>/g, '$1');
            html = html.replace(/<p>(<ul>)/g, '$1');
            html = html.replace(/(<\/ul>)<\/p>/g, '$1');

            return html;
        }

        function parseThinkingBlocks(text) {
            if (!text) return { thinking: [], response: text };
            const thinkingBlocks = [];
            const thinkingRegex = /&lt;thinking&gt;([\s\S]*?)&lt;\/thinking&gt;/gi;
            let match;
            while ((match = thinkingRegex.exec(text)) !== null) {
                thinkingBlocks.push(match[1].trim());
            }
            const cleanResponse = text.replace(thinkingRegex, '').trim();
            return { thinking: thinkingBlocks, response: cleanResponse };
        }

        function renderWithThinking(text) {
            if (!text) return '';
            const { thinking, response } = parseThinkingBlocks(text);
            let html = '';

            if (thinking.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; cursor: pointer;" onclick="toggleThinkingSection(this)">
                            <span style="color: var(--csgo-yellow); font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">Claude Thinking</span>
                            <span style="background: var(--csgo-yellow); color: var(--csgo-black); padding: 2px 8px; border-radius: 10px; font-size: 10px;">${thinking.length} blocks</span>
                            <span style="color: var(--csgo-text-dim); font-size: 14px;" id="thinkingToggleIcon">-</span>
                        </div>
                        <div class="thinking-blocks" style="background: rgba(255, 215, 0, 0.05); border: 1px solid rgba(255, 215, 0, 0.2); border-radius: 5px; padding: 15px;">
                            ${thinking.map((block, i) => `
                                <div style="margin-bottom: ${i < thinking.length - 1 ? '15px' : '0'}; padding-bottom: ${i < thinking.length - 1 ? '15px' : '0'}; ${i < thinking.length - 1 ? 'border-bottom: 1px dashed rgba(255, 215, 0, 0.2);' : ''}">
                                    <div style="font-size: 10px; color: var(--csgo-yellow); margin-bottom: 5px;">THINKING BLOCK ${i + 1}</div>
                                    <div style="font-size: 13px; color: var(--csgo-text); line-height: 1.6; white-space: pre-wrap;">${escapeHtml(block)}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            html += `<div class="response-content">${renderMarkdown(response)}</div>`;
            return html;
        }

        function toggleThinkingSection(header) {
            const blocks = header.nextElementSibling;
            const icon = header.querySelector('#thinkingToggleIcon');
            if (blocks.style.display === 'none') {
                blocks.style.display = 'block';
                icon.textContent = '-';
            } else {
                blocks.style.display = 'none';
                icon.textContent = '+';
            }
        }

        async function loadHistory() {
            try {
                const response = await fetch('/api/prompt/history?limit=20');
                const data = await response.json();

                if (data.success) {
                    state.history = data.history;
                    renderHistory();
                }
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        function renderHistory() {
            const container = document.getElementById('historySection');

            if (state.history.length === 0) {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--csgo-text-dim);">
                        No conversation history yet
                    </div>
                `;
                return;
            }

            container.innerHTML = state.history.map(item => `
                <div class="history-item" onclick="loadHistoryItem('${item.id}')">
                    <div class="history-prompt">${escapeHtml(item.prompt.substring(0, 100))}${item.prompt.length > 100 ? '...' : ''}</div>
                    <div class="history-meta">
                        <span>${formatTime(item.createdAt)}</span>
                        <span>${item.tokensUsed || '-'} tokens</span>
                    </div>
                </div>
            `).join('');
        }

        function loadHistoryItem(id) {
            const item = state.history.find(h => h.id === id);
            if (item) {
                state.currentResponse = {
                    response: item.response,
                    model: 'history',
                    tokensUsed: item.tokensUsed,
                    duration: item.duration
                };
                displayResponse(state.currentResponse);

                document.querySelectorAll('.history-item').forEach(el => el.classList.remove('active'));
                event.currentTarget.classList.add('active');
            }
        }

        async function clearHistory() {
            if (!confirm('Are you sure you want to clear all conversation history?')) return;

            try {
                const response = await fetch('/api/prompt/history', { method: 'DELETE' });
                const data = await response.json();

                if (data.success) {
                    state.history = [];
                    renderHistory();
                    showNotification('History cleared', 'success');

                    document.getElementById('responseViewer').innerHTML = `
                        <div class="response-empty">
                            <h2>Ready to Prompt</h2>
                            <p>Type your prompt below and press Send or Ctrl+Enter</p>
                        </div>
                    `;
                    document.getElementById('responseMeta').style.display = 'none';
                }
            } catch (error) {
                showNotification('Failed to clear history', 'error');
            }
        }

        function updateContext() {
            state.includeCodebase = document.getElementById('includeCodebase').checked;
            renderContextChips();
        }

        function renderContextChips() {
            const container = document.getElementById('contextChips');
            const chips = [];

            if (state.includeCodebase) {
                chips.push(`<span class="context-chip">Codebase <span class="remove" onclick="removeContext('codebase')">x</span></span>`);
            }

            state.selectedMemories.forEach(m => {
                chips.push(`<span class="context-chip">Memory: ${m.content.substring(0, 20)}... <span class="remove" onclick="removeContext('memory', '${m.id}')">x</span></span>`);
            });

            state.selectedFiles.forEach(f => {
                chips.push(`<span class="context-chip">File: ${f.name} <span class="remove" onclick="removeContext('file', '${f.path}')">x</span></span>`);
            });

            container.innerHTML = chips.join('');
        }

        function removeContext(type, id) {
            if (type === 'codebase') {
                state.includeCodebase = false;
                document.getElementById('includeCodebase').checked = false;
            } else if (type === 'memory') {
                state.selectedMemories = state.selectedMemories.filter(m => m.id !== id);
            } else if (type === 'file') {
                state.selectedFiles = state.selectedFiles.filter(f => f.path !== id);
            }
            renderContextChips();
        }

        async function openMemorySelector() {
            document.getElementById('memoryModal').classList.add('active');
            await loadMemories();
        }

        async function loadMemories(search = '') {
            const container = document.getElementById('memoryList');
            container.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-dots"><span></span><span></span><span></span></div>
                </div>
            `;

            try {
                const url = search
                    ? `/api/memories?search=${encodeURIComponent(search)}&limit=50`
                    : '/api/memories?limit=50';

                const response = await fetch(url);
                const data = await response.json();

                if (data.memories && data.memories.length > 0) {
                    container.innerHTML = data.memories.map(m => `
                        <div class="selector-item">
                            <input type="checkbox" id="mem_${m.id}"
                                ${state.selectedMemories.some(sm => sm.id === m.id) ? 'checked' : ''}
                                data-memory='${JSON.stringify({ id: m.id, content: m.content }).replace(/'/g, "&#39;")}'>
                            <div class="selector-item-content">
                                <div class="selector-item-title">${escapeHtml(m.content.substring(0, 100))}${m.content.length > 100 ? '...' : ''}</div>
                                <div class="selector-item-meta">
                                    ${m.memory_type || 'semantic'} | ${m.importance || 'medium'} | ${m.tags?.join(', ') || 'no tags'}
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: var(--csgo-text-dim);">
                            No memories found
                        </div>
                    `;
                }
            } catch (error) {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--csgo-error);">
                        Error loading memories
                    </div>
                `;
            }
        }

        function searchMemories(query) {
            clearTimeout(window.memorySearchTimeout);
            window.memorySearchTimeout = setTimeout(() => loadMemories(query), 300);
        }

        function confirmMemorySelection() {
            const checkboxes = document.querySelectorAll('#memoryList input[type="checkbox"]:checked');
            state.selectedMemories = [];

            checkboxes.forEach(cb => {
                const data = JSON.parse(cb.dataset.memory);
                state.selectedMemories.push(data);
            });

            renderContextChips();
            closeModal('memoryModal');
        }

        async function openFileSelector() {
            document.getElementById('fileModal').classList.add('active');
            await loadFiles();
        }

        async function loadFiles(search = '') {
            const container = document.getElementById('fileList');
            container.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-dots"><span></span><span></span><span></span></div>
                </div>
            `;

            try {
                const url = search
                    ? `/api/codebase?search=${encodeURIComponent(search)}`
                    : '/api/codebase';

                const response = await fetch(url);
                const data = await response.json();

                const files = data.files || data || [];

                if (files.length > 0) {
                    container.innerHTML = files.slice(0, 50).map(f => `
                        <div class="selector-item">
                            <input type="checkbox" id="file_${f.path?.replace(/[^a-z0-9]/gi, '_')}"
                                ${state.selectedFiles.some(sf => sf.path === f.path) ? 'checked' : ''}
                                data-file='${JSON.stringify({ path: f.path, name: f.name || f.path.split('/').pop() }).replace(/'/g, "&#39;")}'>
                            <div class="selector-item-content">
                                <div class="selector-item-title">${escapeHtml(f.name || f.path.split('/').pop())}</div>
                                <div class="selector-item-meta">${escapeHtml(f.path)}</div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: var(--csgo-text-dim);">
                            No files found
                        </div>
                    `;
                }
            } catch (error) {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--csgo-error);">
                        Error loading files
                    </div>
                `;
            }
        }

        function searchFiles(query) {
            clearTimeout(window.fileSearchTimeout);
            window.fileSearchTimeout = setTimeout(() => loadFiles(query), 300);
        }

        function confirmFileSelection() {
            const checkboxes = document.querySelectorAll('#fileList input[type="checkbox"]:checked');
            state.selectedFiles = [];

            checkboxes.forEach(cb => {
                const data = JSON.parse(cb.dataset.file);
                state.selectedFiles.push(data);
            });

            renderContextChips();
            closeModal('fileModal');
        }

        function openDeployModal() {
            const promptInput = document.getElementById('promptInput');
            document.getElementById('deployTaskDescription').value = promptInput.value;
            document.getElementById('deployModal').classList.add('active');
        }

        async function deployTeamMember() {
            const teamMemberName = document.getElementById('deployTeamMemberName').value.trim() || 'Unnamed Team Member';
            const teamMemberType = document.getElementById('deployTeamMemberType').value;
            const taskDescription = document.getElementById('deployTaskDescription').value.trim();
            const useCurrentPrompt = document.getElementById('deployUseCurrentPrompt').checked;

            if (!taskDescription) {
                showNotification('Please provide a task description', 'error');
                return;
            }

            try {
                const response = await fetch('/api/team-members/deploy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: teamMemberName,
                        type: teamMemberType,
                        task: taskDescription,
                        config: {
                            model: document.getElementById('modelSelect').value,
                            maxTokens: parseInt(document.getElementById('maxTokens').value),
                            temperature: parseInt(document.getElementById('temperature').value) / 100,
                            systemPrompt: document.getElementById('systemPrompt').value || undefined,
                            context: {
                                memories: state.selectedMemories.map(m => m.id),
                                files: state.selectedFiles.map(f => f.path),
                                codebase: state.includeCodebase
                            }
                        }
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showNotification(`TeamMember "${teamMemberName}" deployed successfully!`, 'success');
                    closeModal('deployModal');
                } else {
                    showNotification(data.error || 'Failed to deploy team member', 'error');
                }
            } catch (error) {
                console.error('Error deploying team member:', error);
                showNotification('Network error - please try again', 'error');
            }
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('span');

            if (content.style.maxHeight === '0px') {
                content.style.maxHeight = content.scrollHeight + 'px';
                icon.textContent = '-';
            } else {
                content.style.maxHeight = '0px';
                icon.textContent = '+';
            }
        }

        function toggleSystemPrompt() {
            const container = document.getElementById('systemPromptContainer');
            const icon = document.getElementById('systemPromptToggleIcon');
            container.classList.toggle('visible');
            icon.textContent = container.classList.contains('visible') ? '-' : '+';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function updateSliderValue(slider) {
            const valueEl = document.getElementById(slider.id + 'Value');
            if (slider.id === 'maxTokens') {
                // TEAM MEMBER 3 FIX: Display large token values in K format
                const tokens = parseInt(slider.value, 10);
                if (tokens >= 100000) {
                    valueEl.textContent = Math.round(tokens / 1000) + 'K (Unlimited)';
                } else if (tokens >= 1000) {
                    valueEl.textContent = Math.round(tokens / 1000) + 'K';
                } else {
                    valueEl.textContent = tokens;
                }
            } else {
                valueEl.textContent = (slider.value / 100).toFixed(1);
            }
        }

        function updateTemperature(slider) {
            document.getElementById('temperatureValue').textContent = (slider.value / 100).toFixed(2);
        }

        function copyResponse() {
            if (state.currentResponse?.response) {
                navigator.clipboard.writeText(state.currentResponse.response);
                showNotification('Response copied to clipboard', 'success');
            }
        }

        function exportResponse() {
            if (state.currentResponse?.response) {
                const blob = new Blob([state.currentResponse.response], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `response_${Date.now()}.md`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => notification.remove(), 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTime(dateStr) {
            const date = new Date(dateStr);
            const now = new Date();
            const diff = now - date;

            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
            if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
            return date.toLocaleDateString();
        }

        // NOTE: Old polling code removed - using LIVE SSE streaming now!
        // The initializeLiveSessionStream() function handles all real-time updates

        // ========================================================================
        // LIVE TERMINAL - Replace Live Conversation with xterm.js terminal
        // ========================================================================
        let terminalWs = null;
        let term = null;
        let fitAddon = null;

        function initializeTerminal() {
            term = new Terminal({
                cursorBlink: true,
                theme: {
                    background: '#000000',
                    foreground: '#d4d4d4',
                    cursor: '#ffffff',
                    black: '#000000',
                    red: '#cd3131',
                    green: '#0dbc79',
                    yellow: '#e5e510',
                    blue: '#2472c8',
                    magenta: '#bc3fbc',
                    cyan: '#11a8cd',
                    white: '#e5e5e5',
                    brightBlack: '#666666',
                    brightRed: '#f14c4c',
                    brightGreen: '#23d18b',
                    brightYellow: '#f5f543',
                    brightBlue: '#3b8eea',
                    brightMagenta: '#d670d6',
                    brightCyan: '#29b8db',
                    brightWhite: '#ffffff'
                },
                fontSize: 13,
                fontFamily: '"Cascadia Code", "Fira Code", "Consolas", monospace',
                scrollback: 10000,
                convertEol: true
            });

            fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);

            const webLinksAddon = new WebLinksAddon.WebLinksAddon();
            term.loadAddon(webLinksAddon);

            term.open(document.getElementById('terminal'));
            fitAddon.fit();

            window.addEventListener('resize', () => {
                if (fitAddon) fitAddon.fit();
            });

            term.onData((data) => {
                if (terminalWs && terminalWs.readyState === WebSocket.OPEN) {
                    terminalWs.send(JSON.stringify({
                        type: 'send-input',
                        data: data
                    }));
                }
            });

            connectTerminalWebSocket();
        }

        function connectTerminalWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/terminal`;

            terminalWs = new WebSocket(wsUrl);

            terminalWs.onopen = () => {
                try {
                    updateTerminalStatus('connected');
                    term.writeln('\x1b[32m[SpecMem] Connected to terminal stream\x1b[0m');
                    terminalWs.send(JSON.stringify({ type: 'list-instances' }));
                } catch (error) {
                    console.error('[SpecMem] WebSocket onopen error:', error);
                }
            };

            terminalWs.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);

                    if (message.type === 'terminal-output') {
                        term.write(message.data);
                    }
                    else if (message.type === 'instances-list') {
                        term.writeln(`\x1b[33m[SpecMem] Found ${message.instances.length} Claude instances\x1b[0m`);
                        populateInstanceSelector(message.instances);
                    }
                    else if (message.type === 'streaming-started') {
                        term.writeln(`\x1b[32m[SpecMem] Streaming from ${message.instance.screenName}\x1b[0m`);
                        document.getElementById('startStreamBtn').disabled = true;
                        document.getElementById('stopStreamBtn').disabled = false;
                    }
                    else if (message.type === 'streaming-stopped') {
                        term.writeln('\x1b[33m[SpecMem] Streaming stopped\x1b[0m');
                        document.getElementById('startStreamBtn').disabled = false;
                        document.getElementById('stopStreamBtn').disabled = true;
                    }
                    else if (message.type === 'error') {
                        term.writeln(`\x1b[31m[SpecMem Error] ${message.message}\x1b[0m`);
                    }
                } catch (error) {
                    console.error('[SpecMem] WebSocket message handler error:', error);
                    console.error('[SpecMem] Raw message:', event.data);
                    // Don't crash - keep the WebSocket alive
                }
            };

            terminalWs.onerror = (error) => {
                try {
                    console.error('[SpecMem] WebSocket error event:', error);
                    updateTerminalStatus('error');
                    term.writeln('\x1b[31m[SpecMem] WebSocket error\x1b[0m');
                } catch (e) {
                    console.error('[SpecMem] Error in onerror handler:', e);
                }
            };

            terminalWs.onclose = (event) => {
                try {
                    console.log('[SpecMem] WebSocket closed:', event.code, event.reason);
                    updateTerminalStatus('disconnected');
                    term.writeln('\x1b[33m[SpecMem] Disconnected - reconnecting in 3s...\x1b[0m');
                    setTimeout(connectTerminalWebSocket, 3000);
                } catch (error) {
                    console.error('[SpecMem] Error in onclose handler:', error);
                    setTimeout(connectTerminalWebSocket, 3000);
                }
            };
        }

        function updateTerminalStatus(status) {
            const dot = document.getElementById('terminalStatusDot');
            if (status === 'connected') {
                dot.style.background = 'var(--csgo-success)';
            } else if (status === 'error') {
                dot.style.background = 'var(--csgo-error)';
            } else {
                dot.style.background = 'var(--csgo-text-dim)';
            }
        }

        let currentInstances = [];
        function populateInstanceSelector(instances) {
            currentInstances = instances;
            const selector = document.getElementById('instanceSelector');
            selector.innerHTML = '';

            if (instances.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No instances found';
                selector.appendChild(option);
                document.getElementById('startStreamBtn').disabled = true;
                return;
            }

            instances.forEach((instance, index) => {
                const option = document.createElement('option');
                option.value = index;
                const status = instance.attached ? 'Attached' : 'Detached';
                option.textContent = `PID ${instance.pid} - ${instance.screenName} [${status}]`;
                selector.appendChild(option);
            });

            document.getElementById('startStreamBtn').disabled = false;
        }

        document.getElementById('startStreamBtn')?.addEventListener('click', () => {
            if (terminalWs && terminalWs.readyState === WebSocket.OPEN) {
                const selector = document.getElementById('instanceSelector');
                const selectedIndex = parseInt(selector.value);

                if (isNaN(selectedIndex) || !currentInstances[selectedIndex]) {
                    term.writeln('\x1b[31m[SpecMem Error] Please select an instance first\x1b[0m');
                    return;
                }

                const selectedInstance = currentInstances[selectedIndex];
                terminalWs.send(JSON.stringify({
                    type: 'start-streaming',
                    logFile: selectedInstance.logFile,
                    pid: selectedInstance.pid
                }));
            }
        });

        document.getElementById('stopStreamBtn')?.addEventListener('click', () => {
            if (terminalWs && terminalWs.readyState === WebSocket.OPEN) {
                terminalWs.send(JSON.stringify({ type: 'stop-streaming' }));
            }
        });

        document.getElementById('newInstanceBtn')?.addEventListener('click', async () => {
            try {
                const response = await fetch('/api/terminal-inject/new-instance', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                if (result.success) {
                    term.writeln(`\x1b[32m[SpecMem] New instance started: PID ${result.pid}\x1b[0m`);
                    setTimeout(() => {
                        if (terminalWs && terminalWs.readyState === WebSocket.OPEN) {
                            terminalWs.send(JSON.stringify({ type: 'list-instances' }));
                        }
                    }, 2000);
                } else {
                    term.writeln(`\x1b[31m[SpecMem Error] Failed to start new instance: ${result.error}\x1b[0m`);
                }
            } catch (error) {
                term.writeln(`\x1b[31m[SpecMem Error] ${error.message}\x1b[0m`);
            }
        });

        // Initialize terminal when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeTerminal);
        } else {
            initializeTerminal();
        }
    </script>
</body>
</html>
